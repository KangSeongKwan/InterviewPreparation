# 1. 언어
### 1-1. C언어와 C++의 차이점
- 가장 큰 차이점은 자료형의 어려운 개념을 쉽게 만들자는 취지에 있음
- C에서의 자료형은 정수형 및 문자형같은 자료형의 관계를 정확하게 알아야 하고, 기존의 자료형을 결합하는 구조체가 존재하고, 메모리를 어떻게 이용하는지 확인할 수 있는 포인터가 존재한다.
- C++에서는 namespace 개념을 사용한다.(C에서는 식별자의 이름이 같을 수 없지만 C++에서는 식별자의 이름이 같을 수 있다.)
- 표준 입출력 라이브러리가 다르다.(C는 stdio.h를 사용하고, C++은 iostream, STL을 포함한 inline함수, friend함수/클래스 등 객체지향 프로그래밍을 위한 기능을 제공)  
![image](https://user-images.githubusercontent.com/99636945/208810376-0dea7182-a983-4946-b270-d12a6df77123.png)

### 1-2. C#언어와 C++의 차이점
- C++에서 일어나는 버그는 코드상의 메모리 누수이지만 C#은 코드 수준의 메모리가 거의 없다.
- C#은 new 연산자로 할당하면 해제는 Garbage Collecter가 알아서 해주지만, C++은 할당 후 delete나 free로 반드시 해제해야 함
- C#은 형변환이 엄격히 통제되지만, C/C++은 자유로운 편
- C#은 배열 범위를 엄격히 통제한다.(C++은 실행하다가 프로그램이 종료되지만, C#에서는 Exception을 throw함)
- C#은 전역 함수/변수가 존재하지 않고 어떤 클래스의 멤버에 반드시 속해야 함
- C#은 기본 자료형까지도 객체임(Java와 비슷하고 공통조상은 System.Object임)

### 1-3. C++의 장점
- 강력하면서도 유연하다
- 구조화된 프로그램을 짤 수 있다.(한 부분이 잘못 만들어지면 그 부분만 수정함으로써 간편하고 경제적이다.)
- 컴퓨터를 강력하게 제어할 수 있다.(C++언어는 컴퓨터의 기능을 많이 활용할 수 있게 해줌)
- 이식성이 좋고 유연하다.(다양한 기종 및 OS에서 큰 수정없이 사용할 수 있음)

# 2. 객체지향
### 2-1. 객체지향이란?
- 실생활에서 쓰는 모든 것을 객체라고 부른다.
- 객체지향 프로그래밍은 일의 순서대로 프로그래밍 하는 것이 아닌 여러 객체의 협력을 통해 프로그램을 구현하는 것
- 객체는 클래스라는 틀에서 생겨난 실체이다.
- 객체와 객체간의 연결로 구성되며 각각의 객체안에 자료구조/알고리즘이 들어있다.

### 2-2. 객체지향의 4대 특징
- 추상화, 캡슐화, 상속, 다형성이 존재한다.
- 추상화는 실제 세상을 객체화하는게 아니라 필요한 정보만을 중심으로 간소화하는 것을 의미한다.
- 캡슐화는 객체에 필요한 데이터나 기능(메소드)을 책임이 있는 객체에 그룹화시켜주는 것을 의미한다.
- 상속은 상위 클래스의 기능을 하위 클래스가 사용할 수 있는 기능이다. 중복되는 코드의 재사용성을 높여준다.
- 다형성은 하나의 코드가 여러 자료형으로 구현되어 실행되는 것을 의미한다.

### 2-3. 객체지향의 5대 원칙
#### 2-3.1 단일 책임 원칙(SRP)
- 하나의 모듈은 한 가지 책임을 가져야 한다는 것, 모듈이 변경되는 이유는 한 가지여야 함을 의미한다. 
- 제대로 지키면 변경이 필요할 때 수정할 대상이 명확해진다는 장점이 있음
#### 2-3.2 개방 폐쇄 원칙(OCP)
- 확장에 대해 열려있고 수정에 대해서는 닫혀있어야 한다는 의미이다.
- 확장에 열려있다 : 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다.
- 수정에 닫혀있다 : 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.
- 개방 폐쇄 원칙을 지키기 위해서는 추상화에 의존해야 한다.
#### 2-3.3 인터페이스 분리 원칙(ISP)
- 객체가 충분히 높은 응집도의 단위로 설계되었어도 목적과 관심이 각기 다른 클라이언트가 있으면 인터페이스를 통해 적절히 분리해야 한다.
- 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것
- 모든 클라이언트가 자신의 관심에 맞는 public interface만을 접근하여 불필요한 간섭을 최소화 할 수 있음
#### 2-3.4 리스코프 치환 원칙(LSP)
- 하위 타입은 상위 타입을 대체할 수 있어야 한다는 것
- 해당 객체를 사용하는 클라이언트는 상위 타입이 하위 타입으로 변경되어도 차이점을 인식하지 못한 채 상위 타입의 퍼블릭 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다는 것
- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조
- 대체 가능성을 결정해야 하는 것은 해당 객체를 이용하는 클라이언트임
#### 2-3.5 의존성 역전 원칙(DIP)
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되며, 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다는 것
- 고수준 모듈 : 변경이 없는 추상화된 클래스(또는 인터페이스)
- 저수준 모듈 : 변하기 쉬운 구체 클래스
- 추상화에 의존하며 구체화에는 의존하지 않는 설계 원칙
- 의존성 역전 원칙이 위배되면 개방 폐쇄 원칙 역시 위배될 가능성이 높음
- 의존성이 역전되는 시점은 컴파일 시점임을 유의해야 함

# 3. 메모리
### 3-1. 메모리 풀이란?
- 하나의 작업이나 작업 그룹을 처리하기 위해 예약되어 있는 주 메모리 또는 기억장치의 논리적인 영역
- 시스템 상의 모든 주기억장치는 메모리 풀이라고 하는 논리 할당으로 구분됨
- 메모리 풀의 활동 레벨은 메모리 풀에서 동시에 활성화 되는 스레드 수임
- 풀의 수와 크기를 제어함으로써 서브 시스템에서 수행할 작업의 양을 제어할 수 있음
- malloc이나 new 키워드를 사용해서 선언하는 것이 아닌 전역변수로 사용할 메모리를 미리 선언해두는 방식으로 구현한다.

### 3-2. 메모리 구조
- Code 영역, data 영역, Stack 영역, Heap 영역이 존재한다.  
![image](https://user-images.githubusercontent.com/99636945/209055580-4be3eeb7-abee-4d3c-9310-b2c710f8be12.png)
- 코드 영역 : 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 하며 CPU는 코드 영역에 저장된 명령어를 하나씩 가져가 처리
- 데이터 영역 : 프로그램의 전역변수와 정적 변수가 지정되는 영역이고 프로그램의 시작과 함께 할당되고 종료되면 소멸됨
- 스택 영역 : 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다. 함수의 호출과 함께 할당되며 호출이 완료되면 소멸한다. 이 호출 정보를 스택 프레임이라고 함. 높은 주소에서 낮은 주소의 방향으로 할당됨
- 힙 영역 : 사용자가 직접 관리할 수 있는, 관리 해야만 하는 영역이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨. 낮은 주소에서 높은 주소의 방향으로 할당됨

### 3-3. 스택 영역(오버플로우)
- 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다. 함수의 호출과 함께 할당되며 호출이 완료되면 소멸한다. 이 호출 정보를 스택 프레임이라고 함
- 스택은 자료구조의 일종이고, LIFO(후입력선출)의 구조를 지니고 있다. 
- push 동작으로 데이터를 저장하고 pop 동작으로 데이터를 인출한다.
- 스택 프레임이 누적되면 스택 오버플로우가 발생할 수 있는데, 오동작 또는 보안상의 큰 취약점을 가지게 된다.
- C언어에서는 실행중인 프로그램에서 스택 오버플로우가 발생하면 에러를 발생하고 곧바로 강제 종료시킨다.

### 3-4. 힙 영역
- 사용자가 직접 관리할 수 있는, 관리 해야만 하는 영역이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨. 낮은 주소에서 높은 주소의 방향으로 할당됨
- 동적 메모리 할당을 힙 영역에서 진행한다.
- malloc, free, calloc, realloc등의 함수가 존재한다.
- calloc은 malloc과 다르게 메모리의 용량을 인수로 추가로 받고, realloc은 해제된 공간을 크기를 바꾸어 재할당하는 함수임
- 동적 메모리 할당은 메모리 공간이 부족하면 운영체제에 요구해서 할당 받고, 이용을 완료하면 해제하는 것이 가능해 메모리 용량의 제한이 없다.
- 스택과의 차이점은 정적 메모리할당, 동적 메모리 할당 영역이라는 것의 차이점이 있다.

# 4. 자료구조
### 4-1. 자료구조란?
- 컴퓨터가 자료를 인식하고 처리하기 위해서는 2진 코드 체계로 표현되어야 하는데 특정 문제영역에서 개개의 자료들은 서로 연관관계를 가짐으로 문제 해결을 용이하게 한다.
- 위와 같은 연관관계를 자료구조라고 한다.
- 데이터 값의 모임, 데이터간의 관계, 데이터에 적용할 수 있는 함수나 명령을 의미하기도 한다.
- 연관관계의 종류에 따라 선형/비선형 자료구조로 나뉜다.
- 선형 구조는 자료의 저장 방법이나 임의 자료의 입출력 방법에 따라 배열, 스택, 큐, 연결 리스트 등으로 나뉜다.
- 비선형 구조는 자료 항목 사이에 어떤 자료나 관계가 있는 다른 자료가 여러개인 경우, 1:n 또는 m:n 관계인 그래프적 특성을 갖는 구조이다. 트리나 그래프가 이에 속한다.

### 4-2. STL이란?
- C++의 표준 템플릿 라이브러리이다.
- 프로그램에 필요한 자료구조와 알고리즘을 Template로 제공하는 라이브러리이다.
- Container, Iterator, Algorithm, Function Object, Container Adaptor, Allocator로 구성되어 있다.
#### 4-2.1 Container
- 객체를 저장하는 객체, 자료구조라고도 한다. 클래스 템플릿으로 구현되어 있다.
- Sequence Container : array(C++ 11), Vector, list, deque
- Associate Container : set, multiset, map, multimap
#### 4-2.2 Iterator
- 포인터와 비슷한 개념으로 컨테이너의 원소를 가리키고, 가리키는 원소에 접근하여 다음 원소를 가리키는 기능.
#### 4-2.3 Algorithm
- 정렬, 삭제, 검색, 연산 등을 해결하는 일반화된 방법을 제공하는 함수 템플릿
#### 4-2.4 Function Object
- 함수처럼 동작하는 객체로 operator() 연산자를 오버로딩한 객체
- 컨테이너와 알고리즘 등에 클라이언트 정책을 반영하게 된다
#### 4-2.5 Container Adaptor
- 구성요소의 인터페이스르 변경해 새로운 인터페이스를 갖는 구성요소로 변경
- stack, queue, priority_queue등이 해당한다.
#### 4-2.6 Allocator
- 컨테이너의 메모리 할당 정책을 캡슐화한 클래스 객체
- 모든 컨테이너는 자신만의 할당기를 가지고 있다.

### 4-3. 리스트란?
- 자료구조 구현에 활용되는 기초 자료구조
- 자료를 순서대로 한줄로 저장하고, 여러 자료가 일직선으로 연결된 선형 구조
- 제일 처음 데이터를 Head, 마지막 데이터를 Tail이라고 함
- 구현 방식에 따라 배열 리스트, 연결 리스트가 존재함

### 4-4. 벡터란?
- STL 컨테이너 라이브러리의 일종이고 스택과 비슷한 구조를 가지고 있지만 원소를 참조하거나 중간에 값을 삽입하거나 삭제가 가능하다
- 삽입과 삭제는 양쪽 끝(앞, 뒤)에서 이루어진다. 중간에서도 가능함
- 자동으로 메모리가 할당되는 배열이다.
- 배열 기반이기 때문에 임의의 원소에 접근이 가능하다.
- 자료 구조는 아래와 같다.  
![image](https://user-images.githubusercontent.com/99636945/209074997-ef70b3f7-fe7f-4407-ad44-447740916d49.png)
- 멤버함수는 아래와 같은 종류들이 있다.  
![image](https://user-images.githubusercontent.com/99636945/209075071-83312ead-ae3e-45d8-95ef-dfb6ad617316.png)

### 4-5. 벡터의 resize
- 벡터의 사이즈를 사용자가 지정한 사이즈로 변경하는 것
- 새 사이즈가 현재 크기보다 크다면 새롭게 추가된 값들을 기본값으로 채움
- 새 사이즈가 현재 크기보다 작으면 기존 벡터에서 가지고 있던 값 중 초과된 인자값들은 제거함
- reserve 방식도 존재하는데 용량은 늘리지만 사이즈는 변경하지 않는 방식이다.
- 재할당 시간을 줄이는데에 reserve 방식을 사용하여 용량을 미리 확보하는 방식으로 사용할 수 있다.

### 4-6. 벡터의 내적
- std::inner_product를 사용하여 백터의 내적을 계산한다.  
![image](https://user-images.githubusercontent.com/99636945/209078311-8f397508-65d4-4100-893a-d02bc0e8cf8e.png)
- 1~2번째 매개변수는 begin/end 반복자로 지정되고, 세 번째 범위는 begin으로만 지정된다. 4번째는 init을 사용한고 반환 값은 최종 내적값임
- std::transform_reduce, std::execution::par를 사용하여 계산하기도 한다.  
![image](https://user-images.githubusercontent.com/99636945/209078799-bb7c9e9e-f314-4842-a248-e3c3353ffbe9.png)
- transform_reduce의 경우 순서가 맞지 않는 범위에서 작업을 수행할 수 있고 inner_product 알고리즘의 병렬화된 버전임.
- execution::par을 사용하면 알고리즘에 대한 실행 정책을 추가로 지정할 수 있음
![image](https://user-images.githubusercontent.com/99636945/209079205-9e605cd5-f446-4f4d-8051-b6f4f591b92b.png)

### 4-7. 스택이란?
- 메모리에서의 스택 영역과 동일한 개념이며 자료구조의 일종이다.
- LIFO(후입선출력)방식을 따르며 선형 자료구조이며 push로 데이터를 입력하고 pop으로 데이터를 꺼낸다.
- 메모리 정적 할당 방식에서 사용하는 자료구조이고 관련 메소드는 아래와 같이 4가지가 존재한다.
![image](https://user-images.githubusercontent.com/99636945/209268505-89625a2b-84b2-413c-99da-6ea2306baa6c.png)

### 4-8. 큐란?
- 스택과 같은 선형 자료구조이고, FIFO(선입선출력) 방식을 따른다.  
![image](https://user-images.githubusercontent.com/99636945/209274145-902344ad-836e-4b35-8c7b-bb1afb7da97c.png)
- 관련 용어는 다음과 같이 정리된다.  
![image](https://user-images.githubusercontent.com/99636945/209274183-ea9fbeff-3b2a-4c55-acdb-077d2d7f1d90.png)

### 4-8. 맵이란?
- Key 와 Value의 쌍으로 이루어진 자료구조로, Python의 딕셔너리와 같은 구조이다.
- key와 value가 매칭된느 것을 mapping한다고 일컫는다.
![image](https://user-images.githubusercontent.com/99636945/209275416-39b9d40b-6331-419e-b1d1-7ac5ca9f15ad.png)
- key는 중복을 허용하지 않아야 한다. value값에 접근하는 과정에 있어 문제가 발생할 수 있기 때문이다.
- 순서가 중요하지 않고, 이름과 상응하는 데이터를 묶기 위한 자료구조로써 Map 자료구조가 효과적이다.
- 종류는 HashMap, TreeMap, LinkedHashMap 구조가 있다.
#### 4-8.1 HashMap
- Key와 value의 쌍으로만 구성될 뿐 묶여있는 쌍들에 대한 순서는 보장할 수 없다
- 사용자는 키와 값이 구성되는 위치를 결정하거나 알 수 없다.
- Hash 함수를 사용하여 키값과 매칭되는 value값을 찾는다.
#### 4-8.2 TreeMap
- Key의 값을 이용해 순서대로 정렬하여 데이터를 저장하는 자료구조
- Key값을 통한 탐색 뿐 아니라 Key값의 정렬을 통한 탐색 등을 하기에 용이하다.
#### 4-8.3 LinkedHashMap
- 데이터를 입력한 순서대로 쌓아지며 데이터를 저장하는 자료구조
- 배열, 리스트처럼 인덱싱 접근을 하기에 용이하다.

### 4-9. 딕셔너리란?
- key - value 형태의 값을 저장할 수 있는 자료구조이다.
- Set(집합)과 마찬가지로 특정 순서대로 데이터를 리턴하지 않는다.
- 수정이 가능하다.
- key값은 중복될 수 없다. 중복된 key값이 있으면 먼저 있던 Key,Value를 대체한다.



### 4-10. 트리란?
- 노드로 구성된 자료구조로 비선형 자료구조이다. DAG(방향성이 있는 비순환 그래프)의 일종이기도 하다.
- 하나의 루트노드를 가지며 루트노드는 0개 이상의 자식 노드를 가진다. 자식노드 또한 0개 이상의 자식 노드를 갖고, 반복 정의된다.
- 노드 사이에는 간선으로 구성되며 세부 특징은 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209277903-0c2c657c-db7a-4e71-afcb-7bc4942c2d1b.png)
- 트리의 구조와 용어는 아래 그림과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209277970-9b0f79e7-c618-41f8-b043-493f0d311628.png)
- 특징은 아래와 같이 정리된다.
![image](https://user-images.githubusercontent.com/99636945/209278008-3286581f-fe13-4f72-bdb7-4707204ffdf4.png)

### 4-11. 이진 트리란?
- 각 노드가 최대 두개의 자식을 갖는 트리
- 모든 트리가 이진 트리일 수는 없다.
- 중위 순회, 전위 순회, 후위 순회 방식이 있다.
- 중위 순회 : 왼쪽 가지 -> 현재 노드 -> 오른쪽 가지
- 전위 순회 : 현재 노드 -> 왼쪽 가지 -> 오른쪽 가지
- 후위 순회 : 왼쪽 가지 -> 오른쪽 가지 -> 현재 노드
- 이를 활용한 이진 탐색 트리도 존재한다.
- 이진 탐색 트리 : 모든 노드가 모든 왼쪽 자식들 <= n < 모든 오른쪽 자식들(모든 노드 n에 대해서 반드시 성립해야 한다는 특징)을 가진 트리

### 4-12. 레드-블랙 트리란?
- 자가 균형 이진 탐색 트리이다. 다음 조건들을 만족한다.  
![image](https://user-images.githubusercontent.com/99636945/210125355-c4c7a0cd-8572-4ff2-a1fe-e51c019ab8e0.png)
- 삽입 시 Double Red 현상이 발생하지 않기 위해 발생한 상황을 가정한다.
![image](https://user-images.githubusercontent.com/99636945/210125411-f77065bc-6110-442b-b64d-823361d27f7c.png)
- 새로 삽입할 노드를 N, 부모 노드를 P, 조상 노드를 G, 삼촌 노드를 U(부모의 형제노드이다.)라고 가정한다.
- 다음 두 가지 방법을 활용한다.
![image](https://user-images.githubusercontent.com/99636945/210125432-62c9e769-29e9-4b4c-891c-31d5ef9f1f06.png)
- Restructing은 다음과 같은 과정을 거친다.
![image](https://user-images.githubusercontent.com/99636945/210125440-acfe3c6b-d341-4641-b306-d3810bb4aba9.png)
- Recoloring은 다음과 같은 과정을 거친다.  
![image](https://user-images.githubusercontent.com/99636945/210125507-7d26acf3-7067-49f4-ac18-b245a9c378d8.png)
- 중요한 것은 double red만 발생하지 않으면 될 뿐, black은 여러 번 나와도 괜찮다는 점이다.

# 5. OS
- 사용자가 컴퓨터 하드웨어를 효율적으로 운용할 수 있도록 인터페이스를 제공하는 시스템 소프트웨어
- 하드웨어, 소프트웨어 리소스를 관리하고 프로그램을 위한 서비스를 제공
- CPU, 기억장치, 입출력장치, 네트워크 장비 등을 관리함.
- Windows, Linux, MacOS, iOS 등이 있다.
- 컴퓨터의 성능을 높이고, 편의성을 제공하는 것을 목적으로 두고있음
- 하드웨어 자원을 직접 사용하는 것이 아닌, 운영체제가 제공해주는 자원만을 사용할 수 있다.

### 5-1. 세마포어(Semaphore)란?
- 하드웨어 리소스 상태를 나타내는 간단한 카운터 개념이다.
- 비교적 긴 시간을 확보하는 리소스에대해 이용하게 되며 어떤 프로세스가 세마포어를 획득하면 공유 자원에 접근 및 동작을 수행하도록 허용하고 그렇지 않으면 해제를 기다리며 대기
- 운영체제 또는 커널의 한 지정된 저장장치 내 값으로써 각 프로세스는 이를 확인하고 변경할 수 있음.
- 확인되는 값에 따라 그 프로세스가 즉시 자원을 사용할 수 있거나 다른 프로세스가 사용 중이면 재시도하기 전에 일정 시간을 기다려야함
- 이진수(0,1)을 갖고나 추가적인 값을 가질 수 있음
- 세마포어 사용 프로세스는 사용하는 동안 세마포어 값을 변경하여 다른 사용자들이 기다리도록 해야 함

### 5-2. 뮤텍스란?
- Mutual Exclusion의 약자로 상호 배제라고도 한다.
- 공유 자원을 보호하기 위한 짧은 잠금장치이다.
- Critical Session을 가진 쓰레드들의 Running Time이 서로 겹치지 않게 각각 단독으로 실행됨.
- Unlocked(0), Locked(1) 상태를 가진다.
- 뮤텍스 객체는 두 쓰레드가 동시에 사용할 수 없는데, 소유권을 가져 뮤텍스를 획득한 쓰레드만이 뮤텍스를 해제할 수 있기 때문이다.

### 5-3. 세마포어 vs 뮤텍스
- 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없음(Mutex는 상태값이 0,1로 고정되기 때문)
- 세마포어는 소유할 수 없지만 뮤텍스는 소유가 가능하며 소유한 쓰레드가 이에 대한 책임을 짐(Unlock, lock과 연관)
- 뮤텍스의 경우 뮤텍스를 소유한 쓰레드가 해제해야 하지만 세마포어의 경우 소유하지 않은 쓰레드도 세마포어를 해제할 수 있음
- 세마포어는 시스템 번위에 걸쳐있고, 파일 시스템 상의 파일로도 존재하나, 뮤텍스는 프로세스의 범위를 가지며 프로세스가 종료될 때 자동으로 Clean up된다.
- 세마포어는 동기화 대상이 여러개일 수 있지만, 뮤텍스는 오직 하나일 때 사용할 수 있음.

# 6. 네트워크
### 6-1. TCP란?
- OSI 7계층중 4계층인 전송 계층에 존재하는 프로토콜
- 전송 제어 프로토콜이라고 하며 두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜
- 데이터와 패킷이 보내진 순서대로 전달하는 것을 보장함
- 동시제어가 가능하며 컴퓨터와 서버의 대역폭의 깊이가 증가해도 네트워크가 지원됨을 의미
- 연결 지향 프로토콜, 신뢰할 수 있는 프로토콜이라는 특징이 있으며 각 특징의 세부사항은 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209283266-20fe07b6-b576-438b-a743-3a44ed6fcf33.png)
- 연결 설정은 3-way HandShake를 이용한다. 각 단계에 대한 세부사항은 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209284309-1167d797-bc0b-4b2a-9a13-163edeed0af4.png)

### 6-2. UDP란?
- 비연결형 서비스를 지원하며 작지만 빠른 전송이 가능하고 헤더와 전송 데이터에 대한 체크섬 기능을 제공하며 Best Effort 전달 방식을 지원한다.
- TCP보다는 신뢰성이 떨어지며 전송한 데이터 그램이 목적지까지 제대로 도착했는지 확인하지 않는다.
- 헤더 구조는 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209285094-b95e35f7-4159-4379-a18a-2ad81f53000f.png)
- Source Port/Destination Port(송신/수신 포트) : 송수신 프로세스에 할당된 네트워크 포트 번호
- Length(길이) : 프로토콜 헤더를 포함한 UDP 데이터 그램의 전체 크기이다.
- Checksum(체크섬) : 프로토콜 헤더와 데이터에 대한 체크섬 값을 제공하여 수신 프로세스가 데이터그램 변형 오류를 감지할 수 있다.

### 6-3. TCP vs UDP
- 아래 표와 같이 간단하게 정리할 수 있다.
![image](https://user-images.githubusercontent.com/99636945/209285543-140b0a71-4ac9-4002-b26a-24e237247859.png)

# 7. 오버로드/라이딩
### 7-1. 오버로딩이란?
- 사전적으로 과적하다라는 뜻임. C언어에서는 하나의 함수가 하나의 기능만을 구현해야 하는 고유성을 가지고 있음.
- 자바, C#, C++ 등의 객체지향 프로그래밍 언어에서는 하나의 메소드 이름으로 여러 기능을 구현할 수 있다.
- 정의는 한 클래스 내에 이미 사용라혀는 이름과 같은 이름을 가진 메소드가 있더라도 매개변수의 개수 또는 타입이 다르면, 같은 이름을 사용해서 메소드를 정의할 수 있는 것을 의미함.
- 조건은 메소드의 이름이 같고 매개변수의 개수나 타입이 달라야 한다.
- 리턴값만 다른 것은 오버로딩 할 수 없다.
- 접근 제어자도 자유롭게 지정할 수 있다.(public, default, protected, private) 다만, 접근 제어자만 다르게 한다고 오버로딩이 가능하지 않다는 점은 있음.

### 7-2. 오버라이딩이란?
- 부모 클래스로부터 상속받은 메소드를 자식 클래스에서 재정의하는 것이다.
- 상속받은 메소드를 그대로 사용할 수도 있으나 자식 클래스에서 상황에 맞게 변경해야 할 경우 사용한다.
- 자식 클래스에서는 오버라이딩 하고자 하는 메소드의 이름, 매개변수, 리턴값이 모두 같아야 한다.
- 메소드 선언부는 부모의 것과 완벽히 동일해야한다는 의미
- 오버라이딩 시 접근제어자를 설정하는 규칙이 아래와 같이 존재한다.
- 1 : 자식 클래스에서 오버라이딩 하는 메소드의 접근제어자는 부모 클래스보다 더 좁게 설정할 수 없다.
- 2 : 예외는 부모 클래스의 메소드보다 많이 선언할 수 없다.
- 3 : static 메소드를 인스턴스의 메소드로 또는 그 반대로 바꿀 수 없다.

### 7-3. 오버로딩vs오버라이딩
![image](https://user-images.githubusercontent.com/99636945/209419721-0b78fd6e-7a7d-48e4-ae11-8f699861baf5.png)

# 8. 알고리즘
### 8-1. 정렬 알고리즘이란?
- 어떤 데이터셋이 주어졌을 때 이를 정해진 순서대로 나열하여 재배치하는 알고리즘
- 데이터의 정규화 및 의미있는 결과물을 생성하는데 유용하게 사용됨.
- 이미 정렬되어 있다면 이진탐색 같은 강력한 알고리즘을 사용할 수 있지만, 정렬되지 않은 데이터라면 정렬을 우선시 해야함
- 대표적으로 버블정렬, 선택정렬, 삽입정렬, 병합정렬, 퀵정렬 등이 있다.

### 8-2. 버블정렬
- 한번 순회할 때 마다 마지막 하나가 정렬되므로 거품이 올라오는 것 처럼 보이기 때문에 버블정렬이라 불림.
- 직관적인 원리로 구현하긴 편하나 꽤나 비효율적인 방식임.
- 동작 순서는 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209420203-9337aa91-48de-4d3a-9512-a98befc08b75.png)
- 시간 복잡도는 거의 모든 상황에서 최악의 성능을 보여준다. O(n) = n^2의 시간 복잡도를 가진다.
- 공간 복잡도는 주어진 배열 안에서 교환을 진행하므로 O(n)의 공간 복잡도를 가진다.

### 8-3. 선택정렬
- 주어진 자료들 중에서 현재 위치에 맞는 자료를 찾아 선택하여 위치를 교환하는 정렬 알고리즘이다.
- 가장 작은 값의 자료가 0번째 인덱스로 가므로 다음 순회부터는 1번 인덱스부터 순회를 돌며 반복
- 동작 순서는 다음과 같다.
![image](https://user-images.githubusercontent.com/99636945/209420401-5ab73925-d69f-45d2-ad24-47bc8857bbb1.png)
- 시간 복잡도는 최선이든 최악이든 O(n) = n^2의 시간 복잡도를 지닌다. 정렬 되던 아니던 무조건 전체 리스트를 순회하기 때문임.
- 공간 복잡도는 주어진 배열 안에서 교환을 진행하므로 O(n)의 공간 복잡도를 가진다.
 
### 8-4. 삽입정렬
- 주어진 자료의 모든 요소를 앞에서부터 차례대로 정렬된 라ㅛ부분과 비교하여 자신의 위치를 찾아 삽입하는 정렬 알고리즘이다.
- 인간이 직접 정렬하는 순서와 제일 흡사하다고 할 수 있음.
- 동작 순서는 다음과 같다.
![image](https://user-images.githubusercontent.com/99636945/209420440-518698f9-1250-4c17-8ab8-1b1fd2be0566.png)
- 시간 복잡도는 최선의 경우는 전체 자료를 한번만 순회하면 되기 때문에 O(n) = n의 시간 복잡도를 가지지만 최악의 경우는 O(n) = n^2의 시간 복잡도를 가진다.
- 공간 복잡도는 주어진 배열 안에서 교환을 진행하므로 O(n)의 공간 복잡도를 가진다.

### 8-5. 병합정렬
- 일종의 분할/정복 기법을 사용하는 알고리즘으로 큰 문제를 작은 여러개의 문제로 쪼개서 각각 해결 후 결과를 모아서 원래의 문제를 해결하는 방법
- 절차는 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209420555-88c760e4-c4f7-43de-9f91-7303ef9cac57.png)
- 병합정렬은 보통 0번 인덱스의 비교를 반복하기 때문에 재귀 함수로 구현한다.
- 시간복잡도는 항상 O(n) = nlogn의 시간 복잡도를 가지기에 효율적이다. 
- 그러나 원소의 개수만큼 리스트를 쪼개고 따로 저장하고 있어야 하기 때문에 O(n)의 공간 복잡도를 가진다. 메모리를 팔아 수행속도를 얻는셈

### 8-6. 퀵정렬
- 병합정렬과 마찬가지로 분할/정복을 통한 정렬을 수행한다.
- 병합정렬은 분할 단계에서는 아무것도 하지 않고 병합하는 단계에서 수행하나 퀵정렬은 반대로 분할 단계에서 정렬을 수행하고 병합에서 아무것도 하지 않는다.
- 수행 순서는 다음과 같다.
![image](https://user-images.githubusercontent.com/99636945/209420661-aa5e3063-bcb1-46b6-83d5-92bf905223a4.png)
- 시간 복잡도는 평균적으로 O(n) = nlogn의 효율을 보이지만 최악은 O(n) = n^2의 복잡도를 보임. 
- 공간 복잡도는 주어진 배열 안에서 교환을 진행하므로 O(n)의 공간 복잡도를 가진다.
- 
### 8-7. 빅오표기법
- 알고리즘의 효율성을 표기해주는 표기법이다.
- 데이터 개수가 주어졌을 때 덧셈,뺄셈,곱셈 같은 기본 연산의 횟수를 의미함
- 시간 복잡도는 알고리즘의 시간 효율성을 의미, 공간 복잡도는 알고리즘의 메모리 효율성을 의미한다.
- 표기는 O(n), O(nlogn), O(n^2) 처럼 데이터에 대한 절대적인 영향력을 지닌 최고차항만 표기한다.
- 시간 복잡도에 대한 표기법 종류는 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209457636-16ac317e-3e87-4d4d-b988-4b2fb7c07124.png)
- 알고리즘의 시/공간 복잡도는 서로 트레이드오프 관계이다. 빠른 알고리즘은 공간을 많이 먹고, 공간을 적게 차지하는 알고리즘은 실행 시간이 느리다.
- 아닌 알고리즘도 존재한다.

# 9. 함수 호출
### 9-1. Call by Value
- 함수 호출 시 넘기는 인자의 값이 매개변수에 복사되어서 함수 내에서 매개변수에 직접적인 데이터 조작을 가해도 인자에 영향을 주지 않는 것
- 주소 값이 아닌 그 자체로 유의미한 데이터를 값이라고 함.
- 매개변수에 복사되는 값이 데이터 그 자체라는 점이 있기 때문에 함수의 값에는 영향을 주지않음
- 값을 복사해서 처리하기 때문에 메모리 사용량이 늘어난다는 단점이 있음.

### 9-2. Call by Reference
- Call by Value와 원리는 동이랗나 복사되는 값이 데이터의 주소 값이라는 차이점이 존재한다.
- 참조값으로 함수를 호출했다는 뜻이다. C언어의 Call by Reference에서는 함수의 매개변수를 포인터 변수를 사용한다. 
- 자바에서는 포인터가 따로 없고 배열과 클래스가 참조 변수로 Call by Reference로 작동한다.
- 다만 값의 주소를 직접 참조하기 때문에 처리 속도가 빠르다는 장점은 존재한다.

# 10. 클래스
### 10-1. C++ 클래스 및 구조체
- C의 구조체에서 확장된 C++ 구조체의 또 다른 이름
- 변수 및 함수 포함 가능
- 구조체와의 차이는 기본 접근 제어자 뿐이며 구조체는 public, 클래스는 private로 제한되어 있음
- C언어와의 하위 호환성을 위해 동일한 기능을 남겨두었음
- 구조체에서 정의한 내용을 class로 바꾸었을 때 에러가 생길 수 있으므로 다음과 같은 조치를 해야함
- C++ 클래스에서는 private:와 public:으로 변수 및 함수의 접근 제한을 결정해주어야 함.
- 변수는 private, 함수는 public으로 정의하여 변수를 직접 건드리지 않는 방법을 많이 사용함.

### 10-2. C# 클래스 및 구조체
- C++ 과는 다르게 [접근제어자] [클래스/구조체] [이름]으로 정의하는 특징이 있음
- 이러한 이유로 C#은 클래스 전체를 public으로 접근할 수 있도록 선언할 수 있음
- C#내에서 클래스와 구조체의 차이는 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209606163-90ce2933-6379-4e22-a8eb-5be2b628031a.png)

### 10-3. C++ String, C# String 차이
- C++은 문자열 리터럴이 char* 인 반면 C#은 Java와 마찬가지로 언어 수준의 UTF-16 유니코드 문자열 클래스인 string의 인스턴스이다.


# 11. 프로세스
- 현재 실행중인 프로그램을 말함
- PCB의 존재로서 명시되는것(PCB란 Process Controll Block이라고 함)
- 프로세서가 할당되는 개체로서 디스패치가 가능한 단위를 표현함.(준비-> 실행 상태로 넘어가는 과정을 디스패치라고 함)

### 11-1. 멀티 프로세스
- 두 개 이상 다수의 프로세서가 협력적으로 하나 이상의 작업을 동시에 처리하는 것(병렬처리)
- 각 프로세스 간 메모리 구분이 필요하거나 독립된 주소 공간을 가져야 할 경우 사용한다.
- 독립된 구조로 안전성이 높고, 프로세스 중 하나에 문제가 생겨도 다른 프로세스에 영향을 주지않음
- 여러개의 프로세스가 처리되어야 할 때 동일한 데이터를 사용하고 데이터를 하나의 디스크에 두고 모든 프로세서가 이를 공유하면 비용적으로 저렴해짐.
- 독립된 메모리 영역이기 때문에 작업량이 많을 수록 오버헤드(처리 시간이 늦어지는 현상)가 발생하여 성능 저하가 발생할 수 있음.
- Context Switching(문맥 교환) 과정에서 캐시 메모리 초기화 등 무거운 작업이 진행되고 시간이 소모되는 등 오버헤드가 발생한다.

### 11-2. 싱글 쓰레드
- 쓰레드란 프로세스가 할당받은 자원을 이용하는 실행의 단위이다.
- 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 Heap, Data, Code 영역을 공유한다.
- 하나의 프로세스에서 다양한 작업을 담당하는 최소 실행 단위라고 한다.
- 각각의 스레드는 독립적 작업을 수행해야 하므로 고유 스레드ID, 프로그램 카운터, 레지스터 집합, 스택을 가지고 있음
- 싱글스레드란 하나의 프로세스 내의 특정 작업을 하나의 쓰레드로 처리하는 것을 의미한다.  
![image](https://user-images.githubusercontent.com/99636945/209608485-a32134d9-f8cb-4554-8971-06d08a3f0c6a.png)

### 11-3. 멀티 쓰레드 개념 및 장단점
- CPU의 최대 활용을 위해 프로그램의 둘 이상을 동시에 실행하는 기술이다.
- 문맥 교환을 통해서 이루어진다. 하나의 쓰레드에서 다음 쓰레드로 이동하는 과정도 문맥 교환의 일종이다.  
![image](https://user-images.githubusercontent.com/99636945/209608650-e28c7441-a4db-47ee-b2b4-4006d5d7bad2.png)
- 장점으로는 다음과 같은 3가지가 존재한다.  
![image](https://user-images.githubusercontent.com/99636945/209610040-1c854394-bba5-454e-9e79-67c999e63c95.png)
- 단점으로는 다음과 같은 4가지가 존재한다.  
![image](https://user-images.githubusercontent.com/99636945/209610059-54062707-0c1b-4427-88ee-ca639b24ff86.png)

### 11-4. 락
- 여러 스레드 간에 자원을 접근하는 메커니즘을 제공한다.
- 상호배제 정책을 통해 하나의 쓰레드가 특정 자원에 접근중일 경우 다른 쓰레드가 접근하지 못하도록 제한
- 락이 없다면 두 개 이상의 쓰레드가 동시에 접근하므로 데이터의 무결성이 보장되지 않는다.
- 쓰레드는 프로세스의 자원을 공유한다면 락은 쓰레드의 자원 접근을 조율하는데 필요한 열쇠라고 볼 수 있다.

# 12. 박싱, 언박싱
### 12-1. 박싱
- 값 타입을 Object형식 또는 값 형식에서 구현된 임의의 인터페이스 형식으로 변환하는 것이다.
- 보통 암시적으로 변환되며, 명시적 변환도 가능하다.
- object 타입의 작동이 가능한 이유는 object 타입은 모든 자료형(int, float, string, ...)의 최상위 부모이기 때문이다.
- object는 System.Object에서 상속을 받는다. C/C++에서 사용하는 포인터와 유사함.

### 12-2. 언박싱
- Object 형식 또는 인터페이스 형식에서 해당 인터페이스를 값 형식으로 변환하는 것이다.
- 두 가지 절차를 치는데, 개체 인스턴스가 지정한 값 형식을 boxing한 값인지 확인하고 인스턴스의 값을 값 형식 변수에 복사한다.
- 언박싱할 때 다른 타입으로 하거나 해당 타입보다 작은 범위로 변환하면 오류가 발생함.
- 조건을 따진 후 캐스팅을 시도해야 안전함.

# 13. 디자인 패턴
- 프로그램을 개발하는 과정에서 빈번히 발생하는 디자인 문제를 정리해서 상황에 따라 간편하게 적용할 수 있게 정리한 것
- 설계 패턴을 체계적으로 분류하여 개발의 효율성과 재사용성을 높인 것이다.
- 구현 단계에서 해결 방안까지도 제공할 수 있다.
- 기능보다는 구조, 가독성, 확장성에 비중을 둔다.
- 종류는 생성, 구조, 행동 패턴으로 나뉜다.  
![image](https://user-images.githubusercontent.com/99636945/209895431-ab0aefae-b5f5-471f-8226-ab766327b0cd.png)
- 가장 많이 쓰이는 패턴은 GoF 디자인 패턴이다.
- GoF디자인 패턴은 각각의 패턴을 5가지의 생성패턴, 7가지의 구조패턴, 11가지의 행동패턴으로 구분한다.

### 13-1. 생성 패턴
- 객체 인스턴스를 생성하는 패턴으로, 클라이언트와 생성해야 하는 객체 인스턴스 사이의 연결을 끊어주는 패턴
- 싱글턴, 추상 팩토리, 팩토리메소드, 프로토타입, 빌더가 있음
#### 13-1.1 싱글턴 패턴
- 특정 클래스에 객체 인스턴스가 하나만 만들어지도록 해주는 패턴이다. 
- 여러 동일 인스턴스에 의해 성능이 저하되지 않도록 함.
- private로 접근을 제한하고 static으로 정적 변수를 선언한다.
- 사용하면 전역변수를 사용할 때와 마찬가지로 객체 인스턴스를 어디서든지 액세스 할 수 있게 만들 수 있음
#### 13-1.2 추상 팩토리 패턴
- 관련 있는 서브 클래스를 묶어서 팩토리 클래스로 만들고 이들 조건에 따라 객체를 생성하는 패턴이다.
- 객체 생성코드는 상위 클래스에 존재하고 하위 클래스가 객체를 받아 사용함
- 구상 클래스에 의존하지 않고도 서로 연관되거나 의존적인 객체로 이뤄진 제품군을 생산하는 인터페이스를 제공함.
#### 13-1.3 팩토리 메소드 패턴
- 객체 생성을 위한 인터페이스를 정의하여 어떤 클래스가 인스턴스화 될 것인지 서브클래스가 결정하는 패턴
- 객체를 생성할 때 필요한 인터페이스를 만듬.
- 사용자의 입력값이나 조건이 다를 경우 조건에 맞는 다른 객체를 생성할 때 필요한 패턴
#### 13-1.4 프로토타입 패턴
- 성능 향상을 위해 기존 객체를 복사하여 중복 객체를 생성하는 패턴이다.
- 생성하는 객체가 동일하고 객체의 값이나 크기가 변하게 될 때 유용함.
- 생성 시 드는 비용을 줄이기 위해 사용
- 장단점은 다음과 같이 정리된다.  
![image](https://user-images.githubusercontent.com/99636945/209897834-cdf382d5-f6ef-4216-9f60-491600e9ecd2.png)
#### 13-1.5 빌더 패턴
- 많은 인수를 가진 복잡한 객체를 단계적으로 생성하는 것에 초점을 둔 패턴이다.
- 생성 단계를 캡슐화하여 구축 공정을 동일하게 이용하도록 하는 패턴이다.
- 객체의 생성에 있어서 복잡한 과정들을 분리해준다.
- 장단점은 다음과 같이 정리된다.  
![image](https://user-images.githubusercontent.com/99636945/209898996-c2a4d93b-5d33-42d8-b3db-b57b410f7da1.png)

### 13-2. 구조 패턴
- 클래스와 객체를 더 큰 구조로 만들 수 있게 구상을 사용하는 패턴
- 객체에 접근할 수 있는 인터페이스와 새로운 기능을 제공한다.
- 어댑터, 데코레이터, 컴포지트, 플라이웨이트, 브리지, 퍼사드, 프록시가 있다.
#### 13-2.1 어댑터 패턴
- 서로 다른 인터페이스로 인해 함께 사용하지 못하는 클래스를 함께 사용하도록 하는 패턴이다.
- 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환함.
- 이미 만들어져 있는 클래스를 인터페이스가 일치하지 않아 사용하지 못할 때 적용함.
#### 13-2.2 브릿지 패턴
- 하나의 계층에 복잡하게 존재하는 클래스들을 기능 클래스와 구현 클래스로 분리하여 두 클래스를 연결하는 패턴
- 결합도를 낮추고 필요한 부분을 독립적으로 추가할 수 있음
- 상속은 견고한 연결, 브릿지는 느슨한 연결이다.
- 필요에 따라 클래스간의 관계를 손쉽게 바꾸고 싶을 때 사용함.
- 추상화 부분도 바꿔야 할 수 있으며 장단점은 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/210031781-97fcc868-0093-4a53-ae4d-aae7d31675b6.png)
#### 13-2.3 컴포지트 패턴
- 복합 객체와 단일 객체를 동일하게 취급하거나 다룰 수 있는 패턴
- 여러개의 클래스를 모아서 마치 하나의 클래스처럼 취급하게 함
- 클라이언트에서 개별 객체와 복합 객체를 똑같은 방법으로 다룰 수 있음
- 객체를 트리 형태의 구조로 구성해서 부분-전체 계층 구조를 표현하는데 유용함
#### 13-2.4 데코레이터 패턴
- 소스를 변경하지 않고 독립적인 기능을 확장하도록 하는 패턴이다.
- 기존 객체의 메소드에 새로운 행동을 추가하거나 확장할 수 있다.
#### 13-2.5 퍼사드 패턴
- 많은 서브 시스템들이 바람직하지 않은 결합도를 갖거나 서브 시스템들의 구현이 혼잡할 때 사용
- 복잡한 시스템을 구조화하여 쉽게 사용할 수 있도록 하는 패턴이다.
- 클라이언트와 복잡한 서브 시스템 사이에 위치하여 단순화된 하나의 인터페이스를 제공한다.
- 클래스 간 의존 관계가 줄어들고 복잡성이 낮아진다.
- 고수준 인터페이스도 정의하므로 서브 시스템을 더 편리하게 사용할 수 있음.
#### 13-2.6 플라이웨이트 패턴
- 대량의 유사한 작은 객체들을 공유하여 메모리를 가볍게 유지시키는데 유용한 패턴이다.
- 같은 데이터나 코드를 중복생성하지 않도록 관리하는 저장소 풀을 만들어 필요할 때 마다 불러와 사용할 수 있음
- 장단점은 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/210032016-67b65446-5c98-49b4-a6de-c6e532ec6486.png)
#### 13-2.7 프록시 패턴
- 다른 객체로 접근하는 것을 통제하기 위해서 그 객체의 대리자를 제공하는 패턴이다.
- 본인 객체는 은닉하고 대리인 객체를 두고자 할 때 사용
- 서비스 요청이 폭주하는 시간에도 안정되고 빠르게 유지하기 위한 웹툰 서비스 등에 이용한다.

### 13-3. 행동 패턴
- 기능의 구체적인 알고리즘을 정의하는 패턴이다.
- 클래스와 객체들이 상호작용하는 방법과 역할을 분담하는 방법을 다룬다.
- 템플릿 메소드, 커맨드, 반복자, 비지터, 중재자, 메멘토, 옵저버, 상태, 전략, 인터프리터, 책임 연쇄가 있다.
#### 13-3.1 템플릿 메소드 패턴
- 알고리즘에 대한 골격을 정의하고 구체적인 단계는 서브클래스에서 정의하는 패턴이다.
- 고정 기능은 부모 클래스에서 정의하고 변경되는 기능은 서브 클래스에서 구현하도록 한다.
- 알고리즘 구조는 그대로 유지하면서 알고리즘의 특정 단계를 서브클래스에서 재정의할 수 있음.
#### 13-3.2 책임 연쇄 패턴
- 문제의 처리를 담당하는 여러 개의 처리 기능을 두고 순서대로 처리해 나가는 패턴이다.
- 처리하는 객체끼리 연결고리를 만들어 실제 문제를 처리하는 객체를 만날 때 까지 계속해서 요청을 내부적으로 전달함
- 메시지를 보내는 객체와 받아서 처리하는 객체 간의 결합도를 없애기 위한 패턴이다.
- 어떤 요구에 대해 처리해주는 객체의 위치 파악이 힘들 경우 유용하다.
- 하나의 요청을 2개 이상의 객체에서 처리해야 할 경우 사용하기도 한다.
- 장단점은 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/210033489-67e6ae7c-484a-474e-bfa3-309913f92fe7.png)
#### 13-3.3 커맨드 패턴
- 요청 자체를 객체화하여 클라이언트에 매개변수로 넘길 수 있게 하기 위한 패턴
- 여러 기능을 실행할 수록 재사용성이 높은 클래스를 설계하는 패턴이다.
- 실행 취소에 필요한 상태 저장, 로그 기록, 명령어 조합을 가능하게 함
- Composite 패턴을 활용하여 여러 명령어의 구성이 가능하다.
#### 13-3.4 인터프리터 패턴
- 간단한 언어의 문법을 정의, 문장을 구성, 문장을 해석하는 방법을 제시하는 패턴이다.
- 어떤 언어의 인터프리터를 만들 때 사용하면 됨.
- 인터프리터는 소스코드 전체를 해석하는 것이 아닌 한 줄을 순차적으로 해석하는 해석기를 의미하기도 한다.
- 인터프리터 언어의 종류로는 파이썬이 있다.
- 장단점은 다음과 같다.
![image](https://user-images.githubusercontent.com/99636945/210123349-f67921f8-48e3-44d7-970a-3964f7bac868.png)
#### 13-3.5 반복자 패턴
- 내부 데이터 구조를 노출하지 않고 어떤 객체 집합에 속한 원소들을 순차적으로 접근할 수 있도록 하는 패턴이다.
- 컬렉션의 내부 표현은 보여주지 않고 순회하여 원하는 데이터를 찾아갈 수 있게 해준다.
- 트리 자료구조에서 객체를 순차적으로 접근하려 할 경우 사용할 수 있다.
#### 13-3.6 중재자 패턴
- 여러 객체간의 통신 복잡성을 줄이기 위해 사용되는 패턴이다.
- 관련 객체 사이의 통신, 제어를 한곳으로 집중시키기 위해 사용한다.
- 서로 다른 클래스 간 모든 통신을 처리하고 약한 결합으로 코드를 쉽게 유지관리 할 수 있는 중재자 클래스를 제공한다.
- 장단점은 다음과 같다.
![image](https://user-images.githubusercontent.com/99636945/210123671-2af7781e-1911-47ea-a388-4ee9518e611b.png)
#### 13-3.7 메멘토 패턴
- 객체의 상태를 저장해두었다가 복원해야 할 경우 사용하는 패턴이다.
- 캡슐화의 원칙을 지키며 내부 상태를 파악하고 상태를 저장해둔 상태로 다시 복구할 수 있게 한다.
- 장단점은 다음과 같다.
![image](https://user-images.githubusercontent.com/99636945/210123855-c1774367-2e60-4673-a3ca-1d8fb74a72d4.png)
#### 13-3.8 옵저버 패턴
- 1:N 관계의 오브젝트에 대해 감시하고 있다가 특정 객체의 상태가 변하면 다른 모든 객체에게 그 사항을 알리고 필요한 경우 자동적으로 수정이 이루어지도록 하는 패턴이다.
- 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대 다 의존성을 정의한다.
- 다른 객체에 의존하지 않으면서 데이터 변경을 통보할 때 사용한다.
#### 13-3.9 상태 패턴
- 객체 자신의 내부 상태에 따라 기능을 변경하도록 하는 패턴이다.
- 특정 메소드가 객체의 상태에 따라 다른 기능을 수행한다.
- 객체의 클래스가 바뀌는 것 같은 결과를 얻을 수 있다.
#### 13-3.10 전략 패턴
- 클래스별로 캡슐화되어 있는 객체들을 상호교환이 가능하도록 하는 패턴이다.
- 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있는 패턴이다.
- 다형성을 활용하여 특정 객체에 종속되지 않으면서 알고리즘에 대한 확장,변형이 유용하다.
- 상황에 맞게 기능을 변경하고 싶을 때 유용함.
#### 13-3.11 방문자 패턴
- 기존 클래스를 수정하지 않고도 새로운 기능을 추가 가능하게 하는 패턴이다.
- 다양한 객체에 새로운 기능을 추가하는데 캡슐화가 별로 중요하지 않을 때 사용한다.
- 멤버 변수와 멤버 메소드를 다른 클래스로 분리하여 서로 간 호출하게 한다.





