# 1. 언어
### 1-1. C언어와 C++의 차이점
- 가장 큰 차이점은 자료형의 어려운 개념을 쉽게 만들자는 취지에 있음
- C에서의 자료형은 정수형 및 문자형같은 자료형의 관계를 정확하게 알아야 하고, 기존의 자료형을 결합하는 구조체가 존재하고, 메모리를 어떻게 이용하는지 확인할 수 있는 포인터가 존재한다.
- C++에서는 namespace 개념을 사용한다.(C에서는 식별자의 이름이 같을 수 없지만 C++에서는 식별자의 이름이 같을 수 있다.)
- 표준 입출력 라이브러리가 다르다.(C는 stdio.h를 사용하고, C++은 iostream, STL을 포함한 inline함수, friend함수/클래스 등 객체지향 프로그래밍을 위한 기능을 제공)  
![image](https://user-images.githubusercontent.com/99636945/208810376-0dea7182-a983-4946-b270-d12a6df77123.png)

### 1-2. C#언어와 C++의 차이점
- C++에서 일어나는 버그는 코드상의 메모리 누수이지만 C#은 코드 수준의 메모리가 거의 없다.
- C#은 new 연산자로 할당하면 해제는 Garbage Collecter가 알아서 해주지만, C++은 할당 후 delete나 free로 반드시 해제해야 함
- C#은 형변환이 엄격히 통제되지만, C/C++은 자유로운 편
- C#은 배열 범위를 엄격히 통제한다.(C++은 실행하다가 프로그램이 종료되지만, C#에서는 Exception을 throw함)
- C#은 전역 함수/변수가 존재하지 않고 어떤 클래스의 멤버에 반드시 속해야 함
- C#은 기본 자료형까지도 객체임(Java와 비슷하고 공통조상은 System.Object임)

### 1-3. C++의 장점
- 강력하면서도 유연하다
- 구조화된 프로그램을 짤 수 있다.(한 부분이 잘못 만들어지면 그 부분만 수정함으로써 간편하고 경제적이다.)
- 컴퓨터를 강력하게 제어할 수 있다.(C++언어는 컴퓨터의 기능을 많이 활용할 수 있게 해줌)
- 이식성이 좋고 유연하다.(다양한 기종 및 OS에서 큰 수정없이 사용할 수 있음)

# 2. 객체지향
### 2-1. 객체지향이란?
- 실생활에서 쓰는 모든 것을 객체라고 부른다.
- 객체지향 프로그래밍은 일의 순서대로 프로그래밍 하는 것이 아닌 여러 객체의 협력을 통해 프로그램을 구현하는 것
- 객체는 클래스라는 틀에서 생겨난 실체이다.
- 객체와 객체간의 연결로 구성되며 각각의 객체안에 자료구조/알고리즘이 들어있다.

### 2-2. 객체지향의 4대 특징
- 추상화, 캡슐화, 상속, 다형성이 존재한다.
- 추상화는 실제 세상을 객체화하는게 아니라 필요한 정보만을 중심으로 간소화하는 것을 의미한다.
- 캡슐화는 객체에 필요한 데이터나 기능(메소드)을 책임이 있는 객체에 그룹화시켜주는 것을 의미한다.
- 상속은 상위 클래스의 기능을 하위 클래스가 사용할 수 있는 기능이다. 중복되는 코드의 재사용성을 높여준다.
- 다형성은 하나의 코드가 여러 자료형으로 구현되어 실행되는 것을 의미한다.

### 2-3. 객체지향의 5대 원칙
#### 2-3.1 단일 책임 원칙(SRP)
- 하나의 모듈은 한 가지 책임을 가져야 한다는 것, 모듈이 변경되는 이유는 한 가지여야 함을 의미한다. 
- 제대로 지키면 변경이 필요할 때 수정할 대상이 명확해진다는 장점이 있음
#### 2-3.2 개방 폐쇄 원칙(OCP)
- 확장에 대해 열려있고 수정에 대해서는 닫혀있어야 한다는 의미이다.
- 확장에 열려있다 : 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다.
- 수정에 닫혀있다 : 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.
- 개방 폐쇄 원칙을 지키기 위해서는 추상화에 의존해야 한다.
#### 2-3.3 인터페이스 분리 원칙(ISP)
- 객체가 충분히 높은 응집도의 단위로 설계되었어도 목적과 관심이 각기 다른 클라이언트가 있으면 인터페이스를 통해 적절히 분리해야 한다.
- 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것
- 모든 클라이언트가 자신의 관심에 맞는 public interface만을 접근하여 불필요한 간섭을 최소화 할 수 있음
#### 2-3.4 리스코프 치환 원칙(LSP)
- 하위 타입은 상위 타입을 대체할 수 있어야 한다는 것
- 해당 객체를 사용하는 클라이언트는 상위 타입이 하위 타입으로 변경되어도 차이점을 인식하지 못한 채 상위 타입의 퍼블릭 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다는 것
- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조
- 대체 가능성을 결정해야 하는 것은 해당 객체를 이용하는 클라이언트임
#### 2-3.5 의존성 역전 원칙(DIP)
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되며, 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다는 것
- 고수준 모듈 : 변경이 없는 추상화된 클래스(또는 인터페이스)
- 저수준 모듈 : 변하기 쉬운 구체 클래스
- 추상화에 의존하며 구체화에는 의존하지 않는 설계 원칙
- 의존성 역전 원칙이 위배되면 개방 폐쇄 원칙 역시 위배될 가능성이 높음
- 의존성이 역전되는 시점은 컴파일 시점임을 유의해야 함

# 3. 메모리
### 3-1. 메모리 풀이란?
- 하나의 작업이나 작업 그룹을 처리하기 위해 예약되어 있는 주 메모리 또는 기억장치의 논리적인 영역
- 시스템 상의 모든 주기억장치는 메모리 풀이라고 하는 논리 할당으로 구분됨
- 메모리 풀의 활동 레벨은 메모리 풀에서 동시에 활성화 되는 스레드 수임
- 풀의 수와 크기를 제어함으로써 서브 시스템에서 수행할 작업의 양을 제어할 수 있음
- malloc이나 new 키워드를 사용해서 선언하는 것이 아닌 전역변수로 사용할 메모리를 미리 선언해두는 방식으로 구현한다.

### 3-2. 메모리 구조
- Code 영역, data 영역, Stack 영역, Heap 영역이 존재한다.  
![image](https://user-images.githubusercontent.com/99636945/209055580-4be3eeb7-abee-4d3c-9310-b2c710f8be12.png)
- 코드 영역 : 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 하며 CPU는 코드 영역에 저장된 명령어를 하나씩 가져가 처리
- 데이터 영역 : 프로그램의 전역변수와 정적 변수가 지정되는 영역이고 프로그램의 시작과 함께 할당되고 종료되면 소멸됨
- 스택 영역 : 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다. 함수의 호출과 함께 할당되며 호출이 완료되면 소멸한다. 이 호출 정보를 스택 프레임이라고 함. 높은 주소에서 낮은 주소의 방향으로 할당됨
- 힙 영역 : 사용자가 직접 관리할 수 있는, 관리 해야만 하는 영역이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨. 낮은 주소에서 높은 주소의 방향으로 할당됨

### 3-3. 스택 영역(오버플로우)
- 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다. 함수의 호출과 함께 할당되며 호출이 완료되면 소멸한다. 이 호출 정보를 스택 프레임이라고 함
- 스택은 자료구조의 일종이고, LIFO(후입력선출)의 구조를 지니고 있다. 
- push 동작으로 데이터를 저장하고 pop 동작으로 데이터를 인출한다.
- 스택 프레임이 누적되면 스택 오버플로우가 발생할 수 있는데, 오동작 또는 보안상의 큰 취약점을 가지게 된다.
- C언어에서는 실행중인 프로그램에서 스택 오버플로우가 발생하면 에러를 발생하고 곧바로 강제 종료시킨다.

### 3-4. 힙 영역
- 사용자가 직접 관리할 수 있는, 관리 해야만 하는 영역이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨. 낮은 주소에서 높은 주소의 방향으로 할당됨
- 동적 메모리 할당을 힙 영역에서 진행한다.
- malloc, free, calloc, realloc등의 함수가 존재한다.
- calloc은 malloc과 다르게 메모리의 용량을 인수로 추가로 받고, realloc은 해제된 공간을 크기를 바꾸어 재할당하는 함수임
- 동적 메모리 할당은 메모리 공간이 부족하면 운영체제에 요구해서 할당 받고, 이용을 완료하면 해제하는 것이 가능해 메모리 용량의 제한이 없다.
- 스택과의 차이점은 정적 메모리할당, 동적 메모리 할당 영역이라는 것의 차이점이 있다.

# 4. 자료구조
### 4-1. 자료구조란?
- 컴퓨터가 자료를 인식하고 처리하기 위해서는 2진 코드 체계로 표현되어야 하는데 특정 문제영역에서 개개의 자료들은 서로 연관관계를 가짐으로 문제 해결을 용이하게 한다.
- 위와 같은 연관관계를 자료구조라고 한다.
- 데이터 값의 모임, 데이터간의 관계, 데이터에 적용할 수 있는 함수나 명령을 의미하기도 한다.
- 연관관계의 종류에 따라 선형/비선형 자료구조로 나뉜다.
- 선형 구조는 자료의 저장 방법이나 임의 자료의 입출력 방법에 따라 배열, 스택, 큐, 연결 리스트 등으로 나뉜다.
- 비선형 구조는 자료 항목 사이에 어떤 자료나 관계가 있는 다른 자료가 여러개인 경우, 1:n 또는 m:n 관계인 그래프적 특성을 갖는 구조이다. 트리나 그래프가 이에 속한다.

### 4-2. STL이란?
- C++의 표준 템플릿 라이브러리이다.
- 프로그램에 필요한 자료구조와 알고리즘을 Template로 제공하는 라이브러리이다.
- Container, Iterator, Algorithm, Function Object, Container Adaptor, Allocator로 구성되어 있다.
#### 4-2.1 Container
- 객체를 저장하는 객체, 자료구조라고도 한다. 클래스 템플릿으로 구현되어 있다.
- Sequence Container : array(C++ 11), Vector, list, deque
- Associate Container : set, multiset, map, multimap
#### 4-2.2 Iterator
- 포인터와 비슷한 개념으로 컨테이너의 원소를 가리키고, 가리키는 원소에 접근하여 다음 원소를 가리키는 기능.
#### 4-2.3 Algorithm
- 정렬, 삭제, 검색, 연산 등을 해결하는 일반화된 방법을 제공하는 함수 템플릿
#### 4-2.4 Function Object
- 함수처럼 동작하는 객체로 operator() 연산자를 오버로딩한 객체
- 컨테이너와 알고리즘 등에 클라이언트 정책을 반영하게 된다
#### 4-2.5 Container Adaptor
- 구성요소의 인터페이스르 변경해 새로운 인터페이스를 갖는 구성요소로 변경
- stack, queue, priority_queue등이 해당한다.
#### 4-2.6 Allocator
- 컨테이너의 메모리 할당 정책을 캡슐화한 클래스 객체
- 모든 컨테이너는 자신만의 할당기를 가지고 있다.

### 4-3. 리스트란?
- 자료구조 구현에 활용되는 기초 자료구조
- 자료를 순서대로 한줄로 저장하고, 여러 자료가 일직선으로 연결된 선형 구조
- 제일 처음 데이터를 Head, 마지막 데이터를 Tail이라고 함
- 구현 방식에 따라 배열 리스트, 연결 리스트가 존재함

### 4-4. 벡터란?
- STL 컨테이너 라이브러리의 일종이고 스택과 비슷한 구조를 가지고 있지만 원소를 참조하거나 중간에 값을 삽입하거나 삭제가 가능하다
- 삽입과 삭제는 양쪽 끝(앞, 뒤)에서 이루어진다. 중간에서도 가능함
- 자동으로 메모리가 할당되는 배열이다.
- 배열 기반이기 때문에 임의의 원소에 접근이 가능하다.
- 자료 구조는 아래와 같다.  
![image](https://user-images.githubusercontent.com/99636945/209074997-ef70b3f7-fe7f-4407-ad44-447740916d49.png)
- 멤버함수는 아래와 같은 종류들이 있다.  
![image](https://user-images.githubusercontent.com/99636945/209075071-83312ead-ae3e-45d8-95ef-dfb6ad617316.png)

### 4-5. 벡터의 resize
- 벡터의 사이즈를 사용자가 지정한 사이즈로 변경하는 것
- 새 사이즈가 현재 크기보다 크다면 새롭게 추가된 값들을 기본값으로 채움
- 새 사이즈가 현재 크기보다 작으면 기존 벡터에서 가지고 있던 값 중 초과된 인자값들은 제거함
- reserve 방식도 존재하는데 용량은 늘리지만 사이즈는 변경하지 않는 방식이다.
- 재할당 시간을 줄이는데에 reserve 방식을 사용하여 용량을 미리 확보하는 방식으로 사용할 수 있다.

### 4-6. 벡터의 내적
- std::inner_product를 사용하여 백터의 내적을 계산한다.  
![image](https://user-images.githubusercontent.com/99636945/209078311-8f397508-65d4-4100-893a-d02bc0e8cf8e.png)
- 1~2번째 매개변수는 begin/end 반복자로 지정되고, 세 번째 범위는 begin으로만 지정된다. 4번째는 init을 사용한고 반환 값은 최종 내적값임
- std::transform_reduce, std::execution::par를 사용하여 계산하기도 한다.  
![image](https://user-images.githubusercontent.com/99636945/209078799-bb7c9e9e-f314-4842-a248-e3c3353ffbe9.png)
- transform_reduce의 경우 순서가 맞지 않는 범위에서 작업을 수행할 수 있고 inner_product 알고리즘의 병렬화된 버전임.
- execution::par을 사용하면 알고리즘에 대한 실행 정책을 추가로 지정할 수 있음
![image](https://user-images.githubusercontent.com/99636945/209079205-9e605cd5-f446-4f4d-8051-b6f4f591b92b.png)

### 4-7. 스택이란?
- 메모리에서의 스택 영역과 동일한 개념이며 자료구조의 일종이다.
- LIFO(후입선출력)방식을 따르며 선형 자료구조이며 push로 데이터를 입력하고 pop으로 데이터를 꺼낸다.
- 메모리 정적 할당 방식에서 사용하는 자료구조이고 관련 메소드는 아래와 같이 4가지가 존재한다.
![image](https://user-images.githubusercontent.com/99636945/209268505-89625a2b-84b2-413c-99da-6ea2306baa6c.png)

### 4-8. 큐란?
- 스택과 같은 선형 자료구조이고, FIFO(선입선출력) 방식을 따른다.  
![image](https://user-images.githubusercontent.com/99636945/209274145-902344ad-836e-4b35-8c7b-bb1afb7da97c.png)
- 관련 용어는 다음과 같이 정리된다.  
![image](https://user-images.githubusercontent.com/99636945/209274183-ea9fbeff-3b2a-4c55-acdb-077d2d7f1d90.png)

### 4-8. 맵이란?
- Key 와 Value의 쌍으로 이루어진 자료구조로, Python의 딕셔너리와 같은 구조이다.
- key와 value가 매칭된느 것을 mapping한다고 일컫는다.
![image](https://user-images.githubusercontent.com/99636945/209275416-39b9d40b-6331-419e-b1d1-7ac5ca9f15ad.png)
- key는 중복을 허용하지 않아야 한다. value값에 접근하는 과정에 있어 문제가 발생할 수 있기 때문이다.
- 순서가 중요하지 않고, 이름과 상응하는 데이터를 묶기 위한 자료구조로써 Map 자료구조가 효과적이다.
- 종류는 HashMap, TreeMap, LinkedHashMap 구조가 있다.
#### 4-8.1 HashMap
- Key와 value의 쌍으로만 구성될 뿐 묶여있는 쌍들에 대한 순서는 보장할 수 없다
- 사용자는 키와 값이 구성되는 위치를 결정하거나 알 수 없다.
- Hash 함수를 사용하여 키값과 매칭되는 value값을 찾는다.
#### 4-8.2 TreeMap
- Key의 값을 이용해 순서대로 정렬하여 데이터를 저장하는 자료구조
- Key값을 통한 탐색 뿐 아니라 Key값의 정렬을 통한 탐색 등을 하기에 용이하다.
#### 4-8.3 LinkedHashMap
- 데이터를 입력한 순서대로 쌓아지며 데이터를 저장하는 자료구조
- 배열, 리스트처럼 인덱싱 접근을 하기에 용이하다.

### 4-9. 트리란?
- 노드로 구성된 자료구조로 비선형 자료구조이다. DAG(방향성이 있는 비순환 그래프)의 일종이기도 하다.
- 하나의 루트노드를 가지며 루트노드는 0개 이상의 자식 노드를 가진다. 자식노드 또한 0개 이상의 자식 노드를 갖고, 반복 정의된다.
- 노드 사이에는 간선으로 구성되며 세부 특징은 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209277903-0c2c657c-db7a-4e71-afcb-7bc4942c2d1b.png)
- 트리의 구조와 용어는 아래 그림과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209277970-9b0f79e7-c618-41f8-b043-493f0d311628.png)
- 특징은 아래와 같이 정리된다.
![image](https://user-images.githubusercontent.com/99636945/209278008-3286581f-fe13-4f72-bdb7-4707204ffdf4.png)

### 4-10. 이진 트리란?
- 각 노드가 최대 두개의 자식을 갖는 트리
- 모든 트리가 이진 트리일 수는 없다.
- 중위 순회, 전위 순회, 후위 순회 방식이 있다.
- 중위 순회 : 왼쪽 가지 -> 현재 노드 -> 오른쪽 가지
- 전위 순회 : 현재 노드 -> 왼쪽 가지 -> 오른쪽 가지
- 후위 순회 : 왼쪽 가지 -> 오른쪽 가지 -> 현재 노드
- 이를 활용한 이진 탐색 트리도 존재한다.
- 이진 탐색 트리 : 모든 노드가 모든 왼쪽 자식들 <= n < 모든 오른쪽 자식들(모든 노드 n에 대해서 반드시 성립해야 한다는 특징)을 가진 트리

### 4-11. 


# 5. OS
- 사용자가 컴퓨터 하드웨어를 효율적으로 운용할 수 있도록 인터페이스를 제공하는 시스템 소프트웨어
- 하드웨어, 소프트웨어 리소스를 관리하고 프로그램을 위한 서비스를 제공
- CPU, 기억장치, 입출력장치, 네트워크 장비 등을 관리함.
- Windows, Linux, MacOS, iOS 등이 있다.
- 컴퓨터의 성능을 높이고, 편의성을 제공하는 것을 목적으로 두고있음
- 하드웨어 자원을 직접 사용하는 것이 아닌, 운영체제가 제공해주는 자원만을 사용할 수 있다.

### 5-1. 세마포어(Semaphore)란?
- 하드웨어 리소스 상태를 나타내는 간단한 카운터 개념이다.
- 비교적 긴 시간을 확보하는 리소스에대해 이용하게 되며 어떤 프로세스가 세마포어를 획득하면 공유 자원에 접근 및 동작을 수행하도록 허용하고 그렇지 않으면 해제를 기다리며 대기
- 운영체제 또는 커널의 한 지정된 저장장치 내 값으로써 각 프로세스는 이를 확인하고 변경할 수 있음.
- 확인되는 값에 따라 그 프로세스가 즉시 자원을 사용할 수 있거나 다른 프로세스가 사용 중이면 재시도하기 전에 일정 시간을 기다려야함
- 이진수(0,1)을 갖고나 추가적인 값을 가질 수 있음
- 세마포어 사용 프로세스는 사용하는 동안 세마포어 값을 변경하여 다른 사용자들이 기다리도록 해야 함

### 5-2. 뮤텍스란?
- Mutual Exclusion의 약자로 상호 배제라고도 한다.
- 공유 자원을 보호하기 위한 짧은 잠금장치이다.
- Critical Session을 가진 쓰레드들의 Running Time이 서로 겹치지 않게 각각 단독으로 실행됨.
- Unlocked(0), Locked(1) 상태를 가진다.
- 뮤텍스 객체는 두 쓰레드가 동시에 사용할 수 없는데, 소유권을 가져 뮤텍스를 획득한 쓰레드만이 뮤텍스를 해제할 수 있기 때문이다.

### 5-3. 세마포어 vs 뮤텍스
- 세마포어는 뮤텍스가 될 수 있지만 뮤텍스는 세마포어가 될 수 없음(Mutex는 상태값이 0,1로 고정되기 때문)
- 세마포어는 소유할 수 없지만 뮤텍스는 소유가 가능하며 소유한 쓰레드가 이에 대한 책임을 짐(Unlock, lock과 연관)
- 뮤텍스의 경우 뮤텍스를 소유한 쓰레드가 해제해야 하지만 세마포어의 경우 소유하지 않은 쓰레드도 세마포어를 해제할 수 있음
- 세마포어는 시스템 번위에 걸쳐있고, 파일 시스템 상의 파일로도 존재하나, 뮤텍스는 프로세스의 범위를 가지며 프로세스가 종료될 때 자동으로 Clean up된다.
- 세마포어는 동기화 대상이 여러개일 수 있지만, 뮤텍스는 오직 하나일 때 사용할 수 있음.

# 6. 네트워크
### 6-1. TCP란?
- OSI 7계층중 4계층인 전송 계층에 존재하는 프로토콜
- 전송 제어 프로토콜이라고 하며 두 개의 호스트를 연결하고 데이터 스트림을 교환하게 해주는 중요한 네트워크 프로토콜
- 데이터와 패킷이 보내진 순서대로 전달하는 것을 보장함
- 동시제어가 가능하며 컴퓨터와 서버의 대역폭의 깊이가 증가해도 네트워크가 지원됨을 의미
- 연결 지향 프로토콜, 신뢰할 수 있는 프로토콜이라는 특징이 있으며 각 특징의 세부사항은 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209283266-20fe07b6-b576-438b-a743-3a44ed6fcf33.png)
- 연결 설정은 3-way HandShake를 이용한다. 각 단계에 대한 세부사항은 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209284309-1167d797-bc0b-4b2a-9a13-163edeed0af4.png)

### 6-2. UDP란?
- 비연결형 서비스를 지원하며 작지만 빠른 전송이 가능하고 헤더와 전송 데이터에 대한 체크섬 기능을 제공하며 Best Effort 전달 방식을 지원한다.
- TCP보다는 신뢰성이 떨어지며 전송한 데이터 그램이 목적지까지 제대로 도착했는지 확인하지 않는다.
- 헤더 구조는 다음과 같다.  
![image](https://user-images.githubusercontent.com/99636945/209285094-b95e35f7-4159-4379-a18a-2ad81f53000f.png)
- Source Port/Destination Port(송신/수신 포트) : 송수신 프로세스에 할당된 네트워크 포트 번호
- Length(길이) : 프로토콜 헤더를 포함한 UDP 데이터 그램의 전체 크기이다.
- Checksum(체크섬) : 프로토콜 헤더와 데이터에 대한 체크섬 값을 제공하여 수신 프로세스가 데이터그램 변형 오류를 감지할 수 있다.

### 6-3. TCP vs UDP
- 아래 표와 같이 간단하게 정리할 수 있다.
![image](https://user-images.githubusercontent.com/99636945/209285543-140b0a71-4ac9-4002-b26a-24e237247859.png)








