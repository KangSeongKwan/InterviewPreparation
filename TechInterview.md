# 1. 언어
### 1-1. C언어와 C++의 차이점
- 가장 큰 차이점은 자료형의 어려운 개념을 쉽게 만들자는 취지에 있음
- C에서의 자료형은 정수형 및 문자형같은 자료형의 관계를 정확하게 알아야 하고, 기존의 자료형을 결합하는 구조체가 존재하고, 메모리를 어떻게 이용하는지 확인할 수 있는 포인터가 존재한다.
- C++에서는 namespace 개념을 사용한다.(C에서는 식별자의 이름이 같을 수 없지만 C++에서는 식별자의 이름이 같을 수 있다.)
- 표준 입출력 라이브러리가 다르다.(C는 stdio.h를 사용하고, C++은 iostream, STL을 포함한 inline함수, friend함수/클래스 등 객체지향 프로그래밍을 위한 기능을 제공)  
![image](https://user-images.githubusercontent.com/99636945/208810376-0dea7182-a983-4946-b270-d12a6df77123.png)

### 1-2. C#언어와 C++의 차이점
- C++에서 일어나는 버그는 코드상의 메모리 누수이지만 C#은 코드 수준의 메모리가 거의 없다.
- C#은 new 연산자로 할당하면 해제는 Garbage Collecter가 알아서 해주지만, C++은 할당 후 delete나 free로 반드시 해제해야 함
- C#은 형변환이 엄격히 통제되지만, C/C++은 자유로운 편
- C#은 배열 범위를 엄격히 통제한다.(C++은 실행하다가 프로그램이 종료되지만, C#에서는 Exception을 throw함)
- C#은 전역 함수/변수가 존재하지 않고 어떤 클래스의 멤버에 반드시 속해야 함
- C#은 기본 자료형까지도 객체임(Java와 비슷하고 공통조상은 System.Object임)

### 1-3. C++의 장점
- 강력하면서도 유연하다
- 구조화된 프로그램을 짤 수 있다.(한 부분이 잘못 만들어지면 그 부분만 수정함으로써 간편하고 경제적이다.)
- 컴퓨터를 강력하게 제어할 수 있다.(C++언어는 컴퓨터의 기능을 많이 활용할 수 있게 해줌)
- 이식성이 좋고 유연하다.(다양한 기종 및 OS에서 큰 수정없이 사용할 수 있음)

# 2. 객체지향
### 2-1. 객체지향이란?
- 실생활에서 쓰는 모든 것을 객체라고 부른다.
- 객체지향 프로그래밍은 일의 순서대로 프로그래밍 하는 것이 아닌 여러 객체의 협력을 통해 프로그램을 구현하는 것
- 객체는 클래스라는 틀에서 생겨난 실체이다.
- 객체와 객체간의 연결로 구성되며 각각의 객체안에 자료구조/알고리즘이 들어있다.

### 2-2. 객체지향의 4대 특징
- 추상화, 캡슐화, 상속, 다형성이 존재한다.
- 추상화는 실제 세상을 객체화하는게 아니라 필요한 정보만을 중심으로 간소화하는 것을 의미한다.
- 캡슐화는 객체에 필요한 데이터나 기능(메소드)을 책임이 있는 객체에 그룹화시켜주는 것을 의미한다.
- 상속은 상위 클래스의 기능을 하위 클래스가 사용할 수 있는 기능이다. 중복되는 코드의 재사용성을 높여준다.
- 다형성은 하나의 코드가 여러 자료형으로 구현되어 실행되는 것을 의미한다.

### 2-3. 객체지향의 5대 원칙
#### 2-3.1 단일 책임 원칙
- 단일 책임 원칙(SRP) : 하나의 모듈은 한 가지 책임을 가져야 한다는 것, 모듈이 변경되는 이유는 한 가지여야 함을 의미한다. 
- 제대로 지키면 변경이 필요할 때 수정할 대상이 명확해진다는 장점이 있음
#### 2-3.2 개방 폐쇄 원칙
- 개방 폐쇄 원칙(OCP) : 확장에 대해 열려있고 수정에 대해서는 닫혀있어야 한다는 의미이다.
- 확장에 열려있다 : 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다.
- 수정에 닫혀있다 : 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.
- 개방 폐쇄 원칙을 지키기 위해서는 추상화에 의존해야 한다.
#### 2-3.3 인터페이스 분리 원칙
- 인터페이스 분리 원칙(ISP) : 객체가 충분히 높은 응집도의 단위로 설계되었어도 목적과 관심이 각기 다른 클라이언트가 있으면 인터페이스를 통해 적절히 분리해야 한다.
- 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것
- 모든 클라이언트가 자신의 관심에 맞는 public interface만을 접근하여 불필요한 간섭을 최소화 할 수 있음
#### 2-3.4 리스코프 치환 원칙(LSP)
- 하위 타입은 상위 타입을 대체할 수 있어야 한다는 것
- 해당 객체를 사용하는 클라이언트는 상위 타입이 하위 타입으로 변경되어도 차이점을 인식하지 못한 채 상위 타입의 퍼블릭 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다는 것






