# 1. 언어
### 1-1. C언어와 C++의 차이점
- 가장 큰 차이점은 자료형의 어려운 개념을 쉽게 만들자는 취지에 있음
- C에서의 자료형은 정수형 및 문자형같은 자료형의 관계를 정확하게 알아야 하고, 기존의 자료형을 결합하는 구조체가 존재하고, 메모리를 어떻게 이용하는지 확인할 수 있는 포인터가 존재한다.
- C++에서는 namespace 개념을 사용한다.(C에서는 식별자의 이름이 같을 수 없지만 C++에서는 식별자의 이름이 같을 수 있다.)
- 표준 입출력 라이브러리가 다르다.(C는 stdio.h를 사용하고, C++은 iostream, STL을 포함한 inline함수, friend함수/클래스 등 객체지향 프로그래밍을 위한 기능을 제공)  
![image](https://user-images.githubusercontent.com/99636945/208810376-0dea7182-a983-4946-b270-d12a6df77123.png)

### 1-2. C#언어와 C++의 차이점
- C++에서 일어나는 버그는 코드상의 메모리 누수이지만 C#은 코드 수준의 메모리가 거의 없다.
- C#은 new 연산자로 할당하면 해제는 Garbage Collecter가 알아서 해주지만, C++은 할당 후 delete나 free로 반드시 해제해야 함
- C#은 형변환이 엄격히 통제되지만, C/C++은 자유로운 편
- C#은 배열 범위를 엄격히 통제한다.(C++은 실행하다가 프로그램이 종료되지만, C#에서는 Exception을 throw함)
- C#은 전역 함수/변수가 존재하지 않고 어떤 클래스의 멤버에 반드시 속해야 함
- C#은 기본 자료형까지도 객체임(Java와 비슷하고 공통조상은 System.Object임)

### 1-3. C++의 장점
- 강력하면서도 유연하다
- 구조화된 프로그램을 짤 수 있다.(한 부분이 잘못 만들어지면 그 부분만 수정함으로써 간편하고 경제적이다.)
- 컴퓨터를 강력하게 제어할 수 있다.(C++언어는 컴퓨터의 기능을 많이 활용할 수 있게 해줌)
- 이식성이 좋고 유연하다.(다양한 기종 및 OS에서 큰 수정없이 사용할 수 있음)

# 2. 객체지향
### 2-1. 객체지향이란?
- 실생활에서 쓰는 모든 것을 객체라고 부른다.
- 객체지향 프로그래밍은 일의 순서대로 프로그래밍 하는 것이 아닌 여러 객체의 협력을 통해 프로그램을 구현하는 것
- 객체는 클래스라는 틀에서 생겨난 실체이다.
- 객체와 객체간의 연결로 구성되며 각각의 객체안에 자료구조/알고리즘이 들어있다.

### 2-2. 객체지향의 4대 특징
- 추상화, 캡슐화, 상속, 다형성이 존재한다.
- 추상화는 실제 세상을 객체화하는게 아니라 필요한 정보만을 중심으로 간소화하는 것을 의미한다.
- 캡슐화는 객체에 필요한 데이터나 기능(메소드)을 책임이 있는 객체에 그룹화시켜주는 것을 의미한다.
- 상속은 상위 클래스의 기능을 하위 클래스가 사용할 수 있는 기능이다. 중복되는 코드의 재사용성을 높여준다.
- 다형성은 하나의 코드가 여러 자료형으로 구현되어 실행되는 것을 의미한다.

### 2-3. 객체지향의 5대 원칙
#### 2-3.1 단일 책임 원칙(SRP)
- 하나의 모듈은 한 가지 책임을 가져야 한다는 것, 모듈이 변경되는 이유는 한 가지여야 함을 의미한다. 
- 제대로 지키면 변경이 필요할 때 수정할 대상이 명확해진다는 장점이 있음
#### 2-3.2 개방 폐쇄 원칙(OCP)
- 확장에 대해 열려있고 수정에 대해서는 닫혀있어야 한다는 의미이다.
- 확장에 열려있다 : 요구사항이 변경될 때 새로운 동작을 추가하여 애플리케이션의 기능을 확장할 수 있다.
- 수정에 닫혀있다 : 기존의 코드를 수정하지 않고 애플리케이션의 동작을 추가하거나 변경할 수 있다.
- 개방 폐쇄 원칙을 지키기 위해서는 추상화에 의존해야 한다.
#### 2-3.3 인터페이스 분리 원칙(ISP)
- 객체가 충분히 높은 응집도의 단위로 설계되었어도 목적과 관심이 각기 다른 클라이언트가 있으면 인터페이스를 통해 적절히 분리해야 한다.
- 클라이언트의 목적과 용도에 적합한 인터페이스만을 제공하는 것
- 모든 클라이언트가 자신의 관심에 맞는 public interface만을 접근하여 불필요한 간섭을 최소화 할 수 있음
#### 2-3.4 리스코프 치환 원칙(LSP)
- 하위 타입은 상위 타입을 대체할 수 있어야 한다는 것
- 해당 객체를 사용하는 클라이언트는 상위 타입이 하위 타입으로 변경되어도 차이점을 인식하지 못한 채 상위 타입의 퍼블릭 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다는 것
- 자식 클래스가 부모 클래스를 대체하기 위해서는 부모 클래스에 대한 클라이언트의 가정을 준수해야 한다는 것을 강조
- 대체 가능성을 결정해야 하는 것은 해당 객체를 이용하는 클라이언트임
#### 2-3.5 의존성 역전 원칙(DIP)
- 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안되며, 저수준 모듈이 고수준 모듈에서 정의한 추상 타입에 의존해야 한다는 것
- 고수준 모듈 : 변경이 없는 추상화된 클래스(또는 인터페이스)
- 저수준 모듈 : 변하기 쉬운 구체 클래스
- 추상화에 의존하며 구체화에는 의존하지 않는 설계 원칙
- 의존성 역전 원칙이 위배되면 개방 폐쇄 원칙 역시 위배될 가능성이 높음
- 의존성이 역전되는 시점은 컴파일 시점임을 유의해야 함

# 3. 메모리
### 3-1. 메모리 풀이란?
- 하나의 작업이나 작업 그룹을 처리하기 위해 예약되어 있는 주 메모리 또는 기억장치의 논리적인 영역
- 시스템 상의 모든 주기억장치는 메모리 풀이라고 하는 논리 할당으로 구분됨
- 메모리 풀의 활동 레벨은 메모리 풀에서 동시에 활성화 되는 스레드 수임
- 풀의 수와 크기를 제어함으로써 서브 시스템에서 수행할 작업의 양을 제어할 수 있음
- malloc이나 new 키워드를 사용해서 선언하는 것이 아닌 전역변수로 사용할 메모리를 미리 선언해두는 방식으로 구현한다.

### 3-2. 메모리 구조
- Code 영역, data 영역, Stack 영역, Heap 영역이 존재한다.  
![image](https://user-images.githubusercontent.com/99636945/209055580-4be3eeb7-abee-4d3c-9310-b2c710f8be12.png)
- 코드 영역 : 실행할 프로그램의 코드가 저장되는 영역으로 텍스트 영역이라고도 하며 CPU는 코드 영역에 저장된 명령어를 하나씩 가져가 처리
- 데이터 영역 : 프로그램의 전역변수와 정적 변수가 지정되는 영역이고 프로그램의 시작과 함께 할당되고 종료되면 소멸됨
- 스택 영역 : 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다. 함수의 호출과 함께 할당되며 호출이 완료되면 소멸한다. 이 호출 정보를 스택 프레임이라고 함. 높은 주소에서 낮은 주소의 방향으로 할당됨
- 힙 영역 : 사용자가 직접 관리할 수 있는, 관리 해야만 하는 영역이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨. 낮은 주소에서 높은 주소의 방향으로 할당됨

### 3-3. 스택 영역(오버플로우)
- 함수의 호출과 관계되는 지역 변수와 매개변수가 저장되는 영역이다. 함수의 호출과 함께 할당되며 호출이 완료되면 소멸한다. 이 호출 정보를 스택 프레임이라고 함
- 스택은 자료구조의 일종이고, LIFO(후입력선출)의 구조를 지니고 있다. 
- push 동작으로 데이터를 저장하고 pop 동작으로 데이터를 인출한다.
- 스택 프레임이 누적되면 스택 오버플로우가 발생할 수 있는데, 오동작 또는 보안상의 큰 취약점을 가지게 된다.
- C언어에서는 실행중인 프로그램에서 스택 오버플로우가 발생하면 에러를 발생하고 곧바로 강제 종료시킨다.

### 3-4. 힙 영역
- 사용자가 직접 관리할 수 있는, 관리 해야만 하는 영역이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제됨. 낮은 주소에서 높은 주소의 방향으로 할당됨
- 동적 메모리 할당을 힙 영역에서 진행한다.
- malloc, free, calloc, realloc등의 함수가 존재한다.
- calloc은 malloc과 다르게 메모리의 용량을 인수로 추가로 받고, realloc은 해제된 공간을 크기를 바꾸어 재할당하는 함수임
- 동적 메모리 할당은 메모리 공간이 부족하면 운영체제에 요구해서 할당 받고, 이용을 완료하면 해제하는 것이 가능해 메모리 용량의 제한이 없다.
- 스택과의 차이점은 정적 메모리할당, 동적 메모리 할당 영역이라는 것의 차이점이 있다.

# 4. 자료구조
### 4-1. 자료구조란?
- 컴퓨터가 자료를 인식하고 처리하기 위해서는 2진 코드 체계로 표현되어야 하는데 특정 문제영역에서 개개의 자료들은 서로 연관관계를 가짐으로 문제 해결을 용이하게 한다.
- 위와 같은 연관관계를 자료구조라고 한다.
- 데이터 값의 모임, 데이터간의 관계, 데이터에 적용할 수 있는 함수나 명령을 의미하기도 한다.
- 연관관계의 종류에 따라 선형/비선형 자료구조로 나뉜다.
- 선형 구조는 자료의 저장 방법이나 임의 자료의 입출력 방법에 따라 배열, 스택, 큐, 연결 리스트 등으로 나뉜다.
- 비선형 구조는 자료 항목 사이에 어떤 자료나 관계가 있는 다른 자료가 여러개인 경우, 1:n 또는 m:n 관계인 그래프적 특성을 갖는 구조이다. 트리나 그래프가 이에 속한다.

### 4-2. STL이란?
- C++의 표준 템플릿 라이브러리이다.
- 프로그램에 필요한 자료구조와 알고리즘을 Template로 제공하는 라이브러리이다.
- Container, Iterator, Algorithm, Function Object, Container Adaptor, Allocator로 구성되어 있다.
#### 4-2.1 Container
- 객체를 저장하는 객체, 자료구조라고도 한다. 클래스 템플릿으로 구현되어 있다.
- Sequence Container : array(C++ 11), Vector, list, deque
- Associate Container : set, multiset, map, multimap
#### 4-2.2 Iterator
- 포인터와 비슷한 개념으로 컨테이너의 원소를 가리키고, 가리키는 원소에 접근하여 다음 원소를 가리키는 기능.
#### 4-2.3 Algorithm
- 정렬, 삭제, 검색, 연산 등을 해결하는 일반화된 방법을 제공하는 함수 템플릿
#### 4-2.4 Function Object
- 함수처럼 동작하는 객체로 operator() 연산자를 오버로딩한 객체
- 컨테이너와 알고리즘 등에 클라이언트 정책을 반영하게 된다
#### 4-2.5 Container Adaptor
- 구성요소의 인터페이스르 변경해 새로운 인터페이스를 갖는 구성요소로 변경
- stack, queue, priority_queue등이 해당한다.
#### 4-2.6 Allocator
- 컨테이너의 메모리 할당 정책을 캡슐화한 클래스 객체
- 모든 컨테이너는 자신만의 할당기를 가지고 있다.

### 4-3. 리스트란?
- 자료구조 구현에 활용되는 기초 자료구조
- 자료를 순서대로 한줄로 저장하고, 여러 자료가 일직선으로 연결된 선형 구조
- 제일 처음 데이터를 Head, 마지막 데이터를 Tail이라고 함
- 구현 방식에 따라 배열 리스트, 연결 리스트가 존재함

### 4-4. 벡터란?
- STL 컨테이너 라이브러리의 일종이고 스택과 비슷한 구조를 가지고 있지만 원소를 참조하거나 중간에 값을 삽입하거나 삭제가 가능하다
- 삽입과 삭제는 양쪽 끝(앞, 뒤)에서 이루어진다. 중간에서도 가능함
- 자동으로 메모리가 할당되는 배열이다.
- 배열 기반이기 때문에 임의의 원소에 접근이 가능하다.
- 자료 구조는 아래와 같다.  
![image](https://user-images.githubusercontent.com/99636945/209074997-ef70b3f7-fe7f-4407-ad44-447740916d49.png)
- 멤버함수는 아래와 같은 종류들이 있다.  
![image](https://user-images.githubusercontent.com/99636945/209075071-83312ead-ae3e-45d8-95ef-dfb6ad617316.png)

### 4-5. 벡터의 resize
- 벡터의 사이즈를 사용자가 지정한 사이즈로 변경하는 것
- 새 사이즈가 현재 크기보다 크다면 새롭게 추가된 값들을 기본값으로 채움
- 새 사이즈가 현재 크기보다 작으면 기존 벡터에서 가지고 있던 값 중 초과된 인자값들은 제거함
- reserve 방식도 존재하는데 용량은 늘리지만 사이즈는 변경하지 않는 방식이다.
- 재할당 시간을 줄이는데에 reserve 방식을 사용하여 용량을 미리 확보하는 방식으로 사용할 수 있다.

### 4-6. 벡터의 내적
- std::inner_product를 사용하여 백터의 내적을 계산한다.  
![image](https://user-images.githubusercontent.com/99636945/209078311-8f397508-65d4-4100-893a-d02bc0e8cf8e.png)
- 1~2번째 매개변수는 begin/end 반복자로 지정되고, 세 번째 범위는 begin으로만 지정된다. 4번째는 init을 사용한고 반환 값은 최종 내적값임
- std::transform_reduce, std::execution::par를 사용하여 계산하기도 한다.  
![image](https://user-images.githubusercontent.com/99636945/209078799-bb7c9e9e-f314-4842-a248-e3c3353ffbe9.png)
- transform_reduce의 경우 순서가 맞지 않는 범위에서 작업을 수행할 수 있고 inner_product 알고리즘의 병렬화된 버전임.
- execution::par을 사용하면 알고리즘에 대한 실행 정책을 추가로 지정할 수 있음
![image](https://user-images.githubusercontent.com/99636945/209079205-9e605cd5-f446-4f4d-8051-b6f4f591b92b.png)



